"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[5293],{3023(e,n,t){t.d(n,{R:()=>l,x:()=>i});var a=t(3696);const s={},r=a.createContext(s);function l(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(r.Provider,{value:n},e.children)}},4859(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"hooks/useDebounceCallback","title":"useDebounceCallback","description":"A performance-optimized hook that debounces function calls, preventing excessive execution during rapid events. Perfect for search inputs, API calls, resize handlers, and any scenario where you need to delay function execution until a pause in activity.","source":"@site/docs/hooks/useDebounceCallback.md","sourceDirName":"hooks","slug":"/hooks/useDebounceCallback","permalink":"/docs/hooks/useDebounceCallback","draft":false,"unlisted":false,"editUrl":"https://github.com/Oustaa/Kousta-ui/blob/main/docs/docs/hooks/useDebounceCallback.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"usePagination","permalink":"/docs/hooks/usePagination"},"next":{"title":"useScrollLock","permalink":"/docs/hooks/useScrollLock"}}');var s=t(2540),r=t(3023),l=t(7447);const i={sidebar_position:3},o="useDebounceCallback",c={},d=[{value:"When to use",id:"when-to-use",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Values",id:"return-values",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Examples",id:"examples",level:2},{value:"Search Input with API",id:"search-input-with-api",level:3},{value:"Form Validation",id:"form-validation",level:3},{value:"Window Resize Handler",id:"window-resize-handler",level:3},{value:"Auto-Save Functionality",id:"auto-save-functionality",level:3},{value:"Scroll Position Tracking",id:"scroll-position-tracking",level:3},{value:"Button Click Prevention",id:"button-click-prevention",level:3},{value:"Complex API Data Fetching",id:"complex-api-data-fetching",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Debounced Callback with Cleanup",id:"debounced-callback-with-cleanup",level:3},{value:"Multiple Debounced Values",id:"multiple-debounced-values",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"TypeScript Support",id:"typescript-support",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Don&#39;t Use for Critical Actions",id:"dont-use-for-critical-actions",level:3},{value:"Don&#39;t Forget Dependencies",id:"dont-forget-dependencies",level:3},{value:"Don&#39;t Use Very Short Delays",id:"dont-use-very-short-delays",level:3},{value:"Migration from Manual Debounce",id:"migration-from-manual-debounce",level:2},{value:"Before Manual Debounce",id:"before-manual-debounce",level:3},{value:"After useDebounceCallback",id:"after-usedebouncecallback",level:3},{value:"Types (reference)",id:"types-reference",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"usedebouncecallback",children:"useDebounceCallback"})}),"\n",(0,s.jsx)(n.p,{children:"A performance-optimized hook that debounces function calls, preventing excessive execution during rapid events. Perfect for search inputs, API calls, resize handlers, and any scenario where you need to delay function execution until a pause in activity."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use",children:"When to use"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Search inputs"}),": Prevent API calls on every keystroke"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Form validation"}),": Delay validation until user stops typing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Window resize"}),": Handle resize events efficiently"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auto-save"}),": Save drafts after user pauses typing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API rate limiting"}),": Prevent excessive API requests"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scroll handlers"}),": Optimize scroll event performance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Button spam prevention"}),": Prevent multiple rapid clicks"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"callback"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"T extends (...args: any[]) => any"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Required"})}),(0,s.jsx)(n.td,{children:"Function to debounce"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"delay"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"Required"})}),(0,s.jsx)(n.td,{children:"Delay in milliseconds"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"return-values",children:"Return Values"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"debouncedFn"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(...args: Parameters<T>) => void"})}),(0,s.jsx)(n.td,{children:"Debounced version of the callback function"})]})})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(l.A,{color:"blue",children:"Note"})," The hook cleans up its pending timeout automatically on unmount, so you usually don\u2019t need manual cleanup unless you add your own timers."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'import { useDebounceCallback } from "@kousta-ui/hooks";\n\nfunction BasicExample() {\n  const [searchTerm, setSearchTerm] = useState("");\n  \n  const debouncedSearch = useDebounceCallback((term: string) => {\n    console.log("Searching for:", term);\n    // Perform search API call here\n  }, 300);\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setSearchTerm(value);\n    debouncedSearch(value);\n  };\n\n  return (\n    <div>\n      <input\n        type="text"\n        value={searchTerm}\n        onChange={handleInputChange}\n        placeholder="Search..."\n      />\n      <p>Current term: {searchTerm}</p>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h3,{id:"search-input-with-api",children:"Search Input with API"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function SearchExample() {\n  const [query, setQuery] = useState("");\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const searchAPI = async (searchQuery: string) => {\n    if (!searchQuery.trim()) {\n      setResults([]);\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);\n      const data = await response.json();\n      setResults(data.results);\n    } catch (error) {\n      console.error("Search failed:", error);\n      setResults([]);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const debouncedSearch = useDebounceCallback(searchAPI, 500);\n\n  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setQuery(value);\n    debouncedSearch(value);\n  };\n\n  return (\n    <div>\n      <div className="search-container">\n        <input\n          type="text"\n          value={query}\n          onChange={handleSearch}\n          placeholder="Search products..."\n          className="search-input"\n        />\n        {loading && <span className="loading-indicator">Searching...</span>}\n      </div>\n\n      <div className="search-results">\n        {results.map((item) => (\n          <div key={item.id} className="search-result">\n            <h4>{item.title}</h4>\n            <p>{item.description}</p>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"form-validation",children:"Form Validation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function FormValidationExample() {\n  const [email, setEmail] = useState("");\n  const [errors, setErrors] = useState<Record<string, string>>({});\n\n  const validateEmail = (email: string) => {\n    const newErrors: Record<string, string> = {};\n    \n    if (!email) {\n      newErrors.email = "Email is required";\n    } else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)) {\n      newErrors.email = "Please enter a valid email";\n    }\n    \n    setErrors(newErrors);\n  };\n\n  const debouncedValidation = useDebounceCallback(validateEmail, 300);\n\n  const handleEmailChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setEmail(value);\n    debouncedValidation(value);\n  };\n\n  return (\n    <form>\n      <div className="form-group">\n        <label htmlFor="email">Email</label>\n        <input\n          id="email"\n          type="email"\n          value={email}\n          onChange={handleEmailChange}\n          className={errors.email ? "error" : ""}\n        />\n        {errors.email && (\n          <span className="error-message">{errors.email}</span>\n        )}\n      </div>\n    </form>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"window-resize-handler",children:"Window Resize Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function ResizeExample() {\n  const [windowSize, setWindowSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  const handleResize = useDebounceCallback(() => {\n    setWindowSize({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  }, 100);\n\n  useEffect(() => {\n    window.addEventListener("resize", handleResize);\n    return () => window.removeEventListener("resize", handleResize);\n  }, [handleResize]);\n\n  return (\n    <div>\n      <h2>Window Size</h2>\n      <p>Width: {windowSize.width}px</p>\n      <p>Height: {windowSize.height}px</p>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"auto-save-functionality",children:"Auto-Save Functionality"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function AutoSaveExample() {\n  const [content, setContent] = useState("");\n  const [saveStatus, setSaveStatus] = useState<"saved" | "saving" | "unsaved">("saved");\n\n  const saveContent = async (text: string) => {\n    if (!text.trim()) return;\n\n    setSaveStatus("saving");\n    try {\n      // Simulate API call\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      console.log("Content saved:", text);\n      setSaveStatus("saved");\n    } catch (error) {\n      console.error("Save failed:", error);\n      setSaveStatus("unsaved");\n    }\n  };\n\n  const debouncedSave = useDebounceCallback(saveContent, 2000);\n\n  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const value = e.target.value;\n    setContent(value);\n    setSaveStatus("unsaved");\n    debouncedSave(value);\n  };\n\n  return (\n    <div>\n      <div className="editor-header">\n        <h3>Auto-Saving Editor</h3>\n        <span className={`save-status ${saveStatus}`}>\n          {saveStatus === "saved" && "\u2713 Saved"}\n          {saveStatus === "saving" && "Saving..."}\n          {saveStatus === "unsaved" && "Unsaved"}\n        </span>\n      </div>\n      \n      <textarea\n        value={content}\n        onChange={handleContentChange}\n        placeholder="Start typing to see auto-save in action..."\n        rows={10}\n        style={{ width: "100%", padding: "10px" }}\n      />\n      \n      <p className="save-hint">\n        Content will automatically save 2 seconds after you stop typing.\n      </p>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"scroll-position-tracking",children:"Scroll Position Tracking"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function ScrollTrackingExample() {\n  const [scrollPosition, setScrollPosition] = useState(0);\n  const [isScrolling, setIsScrolling] = useState(false);\n\n  const handleScroll = useDebounceCallback(() => {\n    const position = window.scrollY;\n    setScrollPosition(position);\n    setIsScrolling(false);\n  }, 100);\n\n  const handleScrollStart = () => {\n    setIsScrolling(true);\n    handleScroll();\n  };\n\n  useEffect(() => {\n    window.addEventListener("scroll", handleScrollStart);\n    return () => window.removeEventListener("scroll", handleScrollStart);\n  }, [handleScrollStart]);\n\n  return (\n    <div style={{ height: "200vh", padding: "20px" }}>\n      <div style={{ position: "fixed", top: 20, right: 20, background: "white", padding: "10px", border: "1px solid #ccc" }}>\n        <p>Scroll Position: {Math.round(scrollPosition)}px</p>\n        <p>Status: {isScrolling ? "Scrolling..." : "Idle"}</p>\n      </div>\n      \n      <h1>Scroll Down</h1>\n      <p>Scroll position is tracked with debouncing.</p>\n      \n      {/* Lots of content to enable scrolling */}\n      {Array.from({ length: 50 }, (_, i) => (\n        <p key={i}>Section {i + 1} - Scroll to see position tracking in action.</p>\n      ))}\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"button-click-prevention",children:"Button Click Prevention"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function ButtonPreventionExample() {\n  const [clickCount, setClickCount] = useState(0);\n  const [message, setMessage] = useState("");\n\n  const handleClick = useDebounceCallback(() => {\n    setClickCount(prev => prev + 1);\n    setMessage(`Button clicked! Total clicks: ${clickCount + 1}`);\n  }, 1000);\n\n  return (\n    <div>\n      <button onClick={handleClick}>\n        Click Me Rapidly!\n      </button>\n      \n      <p>Click count: {clickCount}</p>\n      <p>{message}</p>\n      \n      <p className="hint">\n        Try clicking the button multiple times quickly - the click handler is debounced by 1 second.\n      </p>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"complex-api-data-fetching",children:"Complex API Data Fetching"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function ComplexDataFetchingExample() {\n  const [filters, setFilters] = useState({\n    category: "",\n    priceRange: [0, 1000],\n    rating: 0,\n  });\n  const [products, setProducts] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  const fetchProducts = async (filterValues: typeof filters) => {\n    setLoading(true);\n    try {\n      const params = new URLSearchParams();\n      \n      if (filterValues.category) {\n        params.append("category", filterValues.category);\n      }\n      params.append("minPrice", filterValues.priceRange[0].toString());\n      params.append("maxPrice", filterValues.priceRange[1].toString());\n      params.append("minRating", filterValues.rating.toString());\n\n      const response = await fetch(`/api/products?${params}`);\n      const data = await response.json();\n      setProducts(data.products);\n    } catch (error) {\n      console.error("Failed to fetch products:", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const debouncedFetch = useDebounceCallback(fetchProducts, 800);\n\n  const handleFilterChange = (newFilters: Partial<typeof filters>) => {\n    const updatedFilters = { ...filters, ...newFilters };\n    setFilters(updatedFilters);\n    debouncedFetch(updatedFilters);\n  };\n\n  return (\n    <div>\n      <div className="filters">\n        <select\n          value={filters.category}\n          onChange={(e) => handleFilterChange({ category: e.target.value })}\n        >\n          <option value="">All Categories</option>\n          <option value="electronics">Electronics</option>\n          <option value="clothing">Clothing</option>\n          <option value="books">Books</option>\n        </select>\n\n        <input\n          type="range"\n          min="0"\n          max="1000"\n          value={filters.priceRange[1]}\n          onChange={(e) => handleFilterChange({ \n            priceRange: [filters.priceRange[0], parseInt(e.target.value)] \n          })}\n        />\n\n        <input\n          type="range"\n          min="0"\n          max="5"\n          value={filters.rating}\n          onChange={(e) => handleFilterChange({ rating: parseInt(e.target.value) })}\n        />\n      </div>\n\n      {loading && <div>Loading products...</div>}\n\n      <div className="products">\n        {products.map((product) => (\n          <div key={product.id} className="product">\n            <h3>{product.name}</h3>\n            <p>${product.price}</p>\n            <div>Rating: {product.rating}\u2605</div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"debounced-callback-with-cleanup",children:"Debounced Callback with Cleanup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function DebounceWithCleanup() {\n  const [results, setResults] = useState([]);\n\n  const searchWithCleanup = useDebounceCallback(async (query: string) => {\n    // Abort controller for cancelling previous requests\n    const controller = new AbortController();\n    \n    try {\n      const response = await fetch(`/api/search?q=${query}`, {\n        signal: controller.signal,\n      });\n      const data = await response.json();\n      \n      // Only update if this request wasn\'t aborted\n      if (!controller.signal.aborted) {\n        setResults(data.results);\n      }\n    } catch (error) {\n      if (error.name !== "AbortError") {\n        console.error("Search failed:", error);\n      }\n    }\n  }, 300);\n\n  return (\n    <div>\n      <input\n        onChange={(e) => searchWithCleanup(e.target.value)}\n        placeholder="Search with cleanup..."\n      />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-debounced-values",children:"Multiple Debounced Values"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function MultipleDebouncedValues() {\n  const [searchTerm, setSearchTerm] = useState("");\n  const [filterTerm, setFilterTerm] = useState("");\n\n  const handleSearch = useDebounceCallback((term: string) => {\n    console.log("Search:", term);\n  }, 300);\n\n  const handleFilter = useDebounceCallback((term: string) => {\n    console.log("Filter:", term);\n  }, 500);\n\n  return (\n    <div>\n      <input\n        placeholder="Search (300ms debounce)"\n        onChange={(e) => {\n          setSearchTerm(e.target.value);\n          handleSearch(e.target.value);\n        }}\n      />\n      \n      <input\n        placeholder="Filter (500ms debounce)"\n        onChange={(e) => {\n          setFilterTerm(e.target.value);\n          handleFilter(e.target.value);\n        }}\n      />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Memory Management"}),": Automatic cleanup of pending timeouts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Latest Callback"}),": Always uses the latest callback version"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient Re-renders"}),": Memoized debounced function prevents unnecessary re-renders"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cleanup on Unmount"}),": Automatically cleans up pending timeouts when component unmounts"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(l.A,{color:"blue",children:"Performance Tip"})," The hook handles cleanup automatically, so you don't need to worry about memory leaks."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,s.jsx)(n.p,{children:"Full TypeScript support with generic inference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Basic usage with inferred types\nconst debouncedFn = useDebounceCallback(\n  (query: string) => console.log(query),\n  300\n);\n\n// Explicit typing\nconst debouncedSearch: (query: string) => void = useDebounceCallback(\n  (query: string) => searchAPI(query),\n  300\n);\n\n// Multiple parameters\nconst debouncedLogger = useDebounceCallback(\n  (message: string, level: "info" | "error" | "warn") => {\n    console[level](message);\n  },\n  200\n);\n\n// Async functions\nconst debouncedFetch = useDebounceCallback(\n  async (url: string) => {\n    const response = await fetch(url);\n    return response.json();\n  },\n  500\n);\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,s.jsx)(n.h3,{id:"dont-use-for-critical-actions",children:"Don't Use for Critical Actions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// \u274c Wrong - don't debounce critical actions like form submission\nconst debouncedSubmit = useDebounceCallback(handleSubmit, 300);\n\n// \u2705 Correct - use immediate execution for critical actions\nconst handleSubmit = () => {\n  // Immediate submission\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dont-forget-dependencies",children:"Don't Forget Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// \u274c Wrong - callback might be stale\nconst [value, setValue] = useState("");\nconst debouncedFn = useDebounceCallback(() => {\n  console.log(value); // Might use stale value\n}, 300);\n\n// \u2705 Correct - pass latest value as parameter\nconst debouncedFn = useDebounceCallback((currentValue: string) => {\n  console.log(currentValue); // Always uses latest value\n}, 300);\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dont-use-very-short-delays",children:"Don't Use Very Short Delays"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// \u274c Wrong - very short delay defeats the purpose\nconst debouncedFn = useDebounceCallback(callback, 10);\n\n// \u2705 Correct - reasonable delay for debouncing\nconst debouncedFn = useDebounceCallback(callback, 300);\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"migration-from-manual-debounce",children:"Migration from Manual Debounce"}),"\n",(0,s.jsx)(n.h3,{id:"before-manual-debounce",children:"Before Manual Debounce"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function OldSearch() {\n  const [query, setQuery] = useState("");\n  const timeoutRef = useRef<NodeJS.Timeout>();\n\n  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setQuery(value);\n    \n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    \n    timeoutRef.current = setTimeout(() => {\n      console.log("Searching:", value);\n    }, 300);\n  };\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <input onChange={handleSearch} placeholder="Search..." />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"after-usedebouncecallback",children:"After useDebounceCallback"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'function NewSearch() {\n  const [query, setQuery] = useState("");\n  \n  const debouncedSearch = useDebounceCallback((searchQuery: string) => {\n    console.log("Searching:", searchQuery);\n  }, 300);\n\n  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setQuery(value);\n    debouncedSearch(value);\n  };\n\n  return (\n    <input onChange={handleSearch} placeholder="Search..." />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"types-reference",children:"Types (reference)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"export function useDebounceCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  delay: number\n): (...args: Parameters<T>) => void;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},7447(e,n,t){t.d(n,{A:()=>s});t(3696);var a=t(2540);function s({children:e,color:n="warning"}){return(0,a.jsx)("span",{className:`badge badge-${n}`,children:e})}}}]);